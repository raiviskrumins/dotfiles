package models

import (
	"bytes"
	"crypto/sha256"
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"io"
	"math/rand"
	"reflect"

	"time"

	"github.com/AmberEngine/api/app"
	"github.com/AmberEngine/api/form"
	"github.com/AmberEngine/api/lib"
	"github.com/AmberEngine/api/oops"
	"github.com/AmberEngine/api/permissions"
	"github.com/AmberEngine/api/pqdb"
)

// APIKey contains the properties necessary to represent the APIKey in the
// database, as well as various CRUD methods.
type APIKey struct {
	ID             lib.IntField    `json:"id" primary:"true"`
	Name           lib.StringField `db:"api_key_name" json:"name"`
	Public         lib.StringField `json:"public"`
	Private        lib.StringField `json:"private"`
	Kind           lib.StringField `json:"kind"` // TODO: make this an ENUM
	ManufacturerID lib.IntField    `json:"manufacturer_id"`
	SalesChannelID lib.IntField    `json:"sales_channel_id"`
	RoleName       lib.StringField `json:"role_name"`
}

func (apiKey APIKey) FormSchema() *form.Schema {
	return nil
}

func (comp *APIKey) NewIterator() *lib.Iterator {
	return &lib.Iterator{DataElem: reflect.ValueOf(comp).Elem(), DataType: reflect.TypeOf(*comp), Current: -1}
}

func (comp *APIKey) ColumnNames() []string {
	return lib.ColumnNames(comp.NewIterator())
}

func (comp *APIKey) Map() map[string]lib.IteratorItem {
	return lib.Map(comp.NewIterator())
}

func (comp *APIKey) SetValue(newComp interface{}) {
	lib.SetFields(comp, newComp)
}

func (apiKey APIKey) TableName() string {
	return "api_key"
}

func (apiKey APIKey) FetchRelation(ctx *app.Context, primaryID driver.Value) (interface{}, oops.Error) {
	return RetrieveManufacturer(ctx, int(primaryID.(int64)))
}

// CreateAPIKey inserts a new API Key into the database and returns
// a populated APIKey instance.
func CreateAPIKey(ctx *app.Context, body io.ReadCloser, clientPublicKey string) (*APIKey, oops.Error) {
	ptr, e := Factory("api_key")
	if e != nil {
		return nil, e
	}
	apiKey := ptr.(*APIKey)

	err := json.NewDecoder(body).Decode(apiKey)
	if err != nil {
		return nil, oops.ServerError("", "Could not decode body into API Key.", err)
	}

	clientAPIKey, e := RetrieveAPIKeyByPublic(ctx, clientPublicKey)
	if e != nil {
		return nil, e
	}

	apiKey.Kind.Set("user_key")
	if ctx.Role["APIKey"]&permissions.APIKeyCreateClient != 0 {
		apiKey.Kind.Set("client_key")
	}
	e = generatePublicPrivateKeys(apiKey, clientAPIKey.Name.String)
	if e != nil {
		return nil, e
	}

	pkID, e := pqdb.CreateModel(ctx, apiKey)
	if e != nil {
		return nil, e
	}

	apiKey.ID.Set(pkID.(int64))

	return apiKey, nil
}

// generatePublicPrivateKeys sets new random strings for the Public & Private
// properties of the provided APIKey instance.
func generatePublicPrivateKeys(apiKey *APIKey, clientName string) oops.Error {
	if apiKey == nil {
		return oops.ServerError("Null pointer reference", "APIKey pointer must not be nil.", clientName)
	}

	if len(clientName) == 0 {
		return oops.NotAcceptable("Client name cannot be empty.", "The client name must have a length greater than 0.", *apiKey)
	}

	if apiKey.Name.Valid != true && len(apiKey.Name.String) == 0 {
		return oops.NotAcceptable("API Key name cannot be empty.", "The APIKey name must be valid and must have a length greater than 0.", *apiKey)
	}

	now := time.Now()
	src := rand.NewSource(now.UnixNano())

	// The first element of this array is for the public-key, the second for the
	// private-key.
	var salts [2]bytes.Buffer

	// Keys are generated from sha256 encrypting a structured salt-string.
	// The salt-string is generated by using the following data:
	// 	1. The name of the clientKey making this request.
	//	2. The current date & time
	//	3. The name of the current API Key instance.
	//	4. A random 256-length alphanumeric string.
	//	5. Either the string "public" or "private", depending on the current type.

	for i, salt := range salts {
		hash := sha256.New()

		salt.WriteString(clientName)
		salt.WriteString(now.String())
		salt.WriteString(apiKey.Name.String)
		salt.WriteString(lib.GenerateRandomAlphaNumericString(256, src))

		if i == 0 {
			salt.WriteString("public")
		} else {
			salt.WriteString("private")
		}

		// Write the bytes to the hash, and store the hashed salt as a stirng.
		hash.Write(salt.Bytes())
		hashedSalt := fmt.Sprintf("%x", hash.Sum([]byte{}))

		_, err := salts[i].WriteString(hashedSalt)
		if err != nil {
			return oops.ServerError("", "Failed to write hashed-salt to buffer.", err, i, hashedSalt)
		}
	}

	apiKey.Public.Set(salts[0].String())
	apiKey.Private.Set(salts[1].String())

	return nil
}

// RetrieveAPIKey returns an APIKey instance populated from the database where
// the entry's primary-key matches the specified ID number.
func RetrieveAPIKey(ctx *app.Context, apiKeyID int) (*APIKey, oops.Error) {
	ptr, e := Factory("api_key")
	if e != nil {
		return nil, e
	}

	apiKey := ptr.(*APIKey)
	table := pqdb.NewTable(apiKey.TableName())

	var wheres []pqdb.WhereItem
	wheres = append(wheres, pqdb.MakeWhereItem("", pqdb.Predicate{table.Column("id"), "=", apiKeyID}))
	if ctx.Role["APIKey"]&permissions.APIKeyRetrieveOwn != 0 {
		wheres = append(wheres, pqdb.MakeWhereItem("AND", pqdb.Predicate{"public", "=", ctx.APIKey.(*APIKey).Public.String}))
	}

	e = pqdb.RetrieveModel(ctx, apiKey, wheres)
	if e != nil {
		return nil, e
	}

	return apiKey, nil
}

// RetrieveAPIKeyByPublic returns an APIKey instance populated by the database,
// where the entry's public key matches the public-key argument.
func RetrieveAPIKeyByPublic(ctx *app.Context, publicKey string) (*APIKey, oops.Error) {
	if len(publicKey) == 0 {
		return nil, oops.BadRequest("Missing public key")
	}

	ptr, e := Factory("api_key")
	if e != nil {
		return nil, e
	}
	apiKey := ptr.(*APIKey)
	table := pqdb.NewTable(apiKey.TableName())

	var where []pqdb.WhereItem
	where = append(where, pqdb.MakeWhereItem("", pqdb.Predicate{table.Column("public"), "=", publicKey}))

	if _, ok := ctx.Role["APIKey"]; ok {
		// TODO: Is this permission stuff correct?
		if ctx.Role["APIKey"]&permissions.APIKeyRetrieveOwn != 0 {
			where = append(where, pqdb.MakeWhereItem("", pqdb.Predicate{table.Column("public"), "=", ctx.APIKey.(*APIKey).Public.String}))
		}
	}

	e = pqdb.RetrieveModel(ctx, apiKey, where)
	if e != nil {
		return nil, e
	}

	return apiKey, nil
}

// UpdateAPIKey updates the APIKey with the provided JSON where the entry
// matches the primary-key specified.
func UpdateAPIKey(ctx *app.Context, apiKeyID int, body io.ReadCloser) (*APIKey, oops.Error) {
	apiKey, e := RetrieveAPIKey(ctx, apiKeyID)
	if e != nil {
		return nil, e
	}

	err := json.NewDecoder(body).Decode(apiKey)
	if err != nil {
		return nil, oops.ServerError("", "Failed to decode JSON into API Key instance.", err, body)
	}

	var wheres []pqdb.WhereItem
	if ctx.Role["APIKey"]&permissions.APIKeyUpdateOwn != 0 {
		wheres = append(wheres, pqdb.MakeWhereItem("", pqdb.Predicate{"public", "=", ctx.APIKey.(*APIKey).Public.String}))
	}

	wheres = append(wheres, pqdb.MakeWhereItem("", pqdb.Predicate{"id", "=", apiKeyID}))

	e = pqdb.UpdateModel(ctx, apiKey, wheres)
	if e != nil {
		return nil, e
	}
	return apiKey, nil
}

// DeleteAPIKey will delete the specified entry from the database. The API
// Key is specified by providing its primary-key ID.
func DeleteAPIKey(ctx *app.Context, apiKeyID int) oops.Error {
	ptr, e := Factory("api_key")
	if e != nil {
		return e
	}
	apiKey := ptr.(*APIKey)

	var preds []pqdb.Predicate
	if ctx.Role["APIKey"]&permissions.APIKeyDeleteOwn != 0 {
		preds = append(preds, pqdb.Predicate{"public", "=", ctx.APIKey.(*APIKey).Public.String})
	}
	preds = append(preds, pqdb.Predicate{"id", "=", apiKeyID})
	queryParams, e := pqdb.NewQueryParams(0, 0, preds...)
	if e != nil {
		return e
	}

	e = pqdb.DeleteQuery(ctx.DBConn, apiKey.TableName(), queryParams)
	if e != nil {
		return e
	}

	return nil
}
